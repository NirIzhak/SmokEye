{"ast":null,"code":"'use strict';\n\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport ListMetricsAggregator from './ListMetricsAggregator';\nvar Info = _createClass(function Info() {\n  _classCallCheck(this, Info);\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n});\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\nvar _sampleRate = DEBUG ? 1 : null;\nvar FillRateHelper = function () {\n  function FillRateHelper(listMetrics) {\n    _classCallCheck(this, FillRateHelper);\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n  _createClass(FillRateHelper, [{\n    key: \"activate\",\n    value: function activate() {\n      if (this._enabled && this._samplesStartTime == null) {\n        DEBUG && console.debug('FillRateHelper: activate');\n        this._samplesStartTime = global.performance.now();\n      }\n    }\n  }, {\n    key: \"deactivateAndFlush\",\n    value: function deactivateAndFlush() {\n      if (!this._enabled) {\n        return;\n      }\n      var start = this._samplesStartTime;\n      if (start == null) {\n        DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n        return;\n      }\n      if (this._info.sample_count < _minSampleCount) {\n        this._resetData();\n        return;\n      }\n      var total_time_spent = global.performance.now() - start;\n      var info = _objectSpread(_objectSpread({}, this._info), {}, {\n        total_time_spent: total_time_spent\n      });\n      if (DEBUG) {\n        var derived = {\n          avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n          avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n          avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n          any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n          any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n          mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n          mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n        };\n        for (var key in derived) {\n          derived[key] = Math.round(1000 * derived[key]) / 1000;\n        }\n        console.debug('FillRateHelper deactivateAndFlush: ', {\n          derived: derived,\n          info: info\n        });\n      }\n      _listeners.forEach(function (listener) {\n        return listener(info);\n      });\n      this._resetData();\n    }\n  }, {\n    key: \"computeBlankness\",\n    value: function computeBlankness(props, cellsAroundViewport, scrollMetrics) {\n      if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {\n        return 0;\n      }\n      var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength;\n      this._info.sample_count++;\n      this._info.pixels_sampled += Math.round(visibleLength);\n      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n      var scrollSpeed = Math.round(Math.abs(velocity) * 1000);\n      var now = global.performance.now();\n      if (this._anyBlankStartTime != null) {\n        this._info.any_blank_ms += now - this._anyBlankStartTime;\n      }\n      this._anyBlankStartTime = null;\n      if (this._mostlyBlankStartTime != null) {\n        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n      }\n      this._mostlyBlankStartTime = null;\n      var blankTop = 0;\n      var first = cellsAroundViewport.first;\n      var firstFrame = this._listMetrics.getCellMetrics(first, props);\n      while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.isMounted)) {\n        firstFrame = this._listMetrics.getCellMetrics(first, props);\n        first++;\n      }\n      if (firstFrame && first > 0) {\n        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n      }\n      var blankBottom = 0;\n      var last = cellsAroundViewport.last;\n      var lastFrame = this._listMetrics.getCellMetrics(last, props);\n      while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.isMounted)) {\n        lastFrame = this._listMetrics.getCellMetrics(last, props);\n        last--;\n      }\n      if (lastFrame && last < props.getItemCount(props.data) - 1) {\n        var bottomEdge = lastFrame.offset + lastFrame.length;\n        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n      }\n      var pixels_blank = Math.round(blankTop + blankBottom);\n      var blankness = pixels_blank / visibleLength;\n      if (blankness > 0) {\n        this._anyBlankStartTime = now;\n        this._info.any_blank_speed_sum += scrollSpeed;\n        this._info.any_blank_count++;\n        this._info.pixels_blank += pixels_blank;\n        if (blankness > 0.5) {\n          this._mostlyBlankStartTime = now;\n          this._info.mostly_blank_count++;\n        }\n      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n        this.deactivateAndFlush();\n      }\n      return blankness;\n    }\n  }, {\n    key: \"enabled\",\n    value: function enabled() {\n      return this._enabled;\n    }\n  }, {\n    key: \"_resetData\",\n    value: function _resetData() {\n      this._anyBlankStartTime = null;\n      this._info = new Info();\n      this._mostlyBlankStartTime = null;\n      this._samplesStartTime = null;\n    }\n  }], [{\n    key: \"addListener\",\n    value: function addListener(callback) {\n      if (_sampleRate === null) {\n        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n      }\n      _listeners.push(callback);\n      return {\n        remove: function remove() {\n          _listeners = _listeners.filter(function (listener) {\n            return callback !== listener;\n          });\n        }\n      };\n    }\n  }, {\n    key: \"setSampleRate\",\n    value: function setSampleRate(sampleRate) {\n      _sampleRate = sampleRate;\n    }\n  }, {\n    key: \"setMinSampleCount\",\n    value: function setMinSampleCount(minSampleCount) {\n      _minSampleCount = minSampleCount;\n    }\n  }]);\n  return FillRateHelper;\n}();\nmodule.exports = FillRateHelper;","map":{"version":3,"names":["_defineProperty","_createClass","_classCallCheck","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","ListMetricsAggregator","Info","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","listMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_listMetrics","Math","random","_resetData","value","activate","console","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","round","listener","computeBlankness","props","cellsAroundViewport","scrollMetrics","getItemCount","data","last","first","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","firstFrame","getCellMetrics","isMounted","min","max","blankBottom","lastFrame","bottomEdge","blankness","enabled","addListener","callback","warn","remove","setSampleRate","sampleRate","setMinSampleCount","minSampleCount","module","exports"],"sources":["C:/Users/NIR67/OneDrive/שולחן העבודה/SmokEye/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {CellMetricProps} from './ListMetricsAggregator';\nimport ListMetricsAggregator from './ListMetricsAggregator';\n\nexport type FillRateInfo = Info;\n\nclass Info {\n  any_blank_count: number = 0;\n  any_blank_ms: number = 0;\n  any_blank_speed_sum: number = 0;\n  mostly_blank_count: number = 0;\n  mostly_blank_ms: number = 0;\n  pixels_blank: number = 0;\n  pixels_sampled: number = 0;\n  pixels_scrolled: number = 0;\n  total_time_spent: number = 0;\n  sample_count: number = 0;\n}\n\nconst DEBUG = false;\n\nlet _listeners: Array<(Info) => void> = [];\nlet _minSampleCount = 10;\nlet _sampleRate = DEBUG ? 1 : null;\n\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\nclass FillRateHelper {\n  _anyBlankStartTime: ?number = null;\n  _enabled = false;\n  _listMetrics: ListMetricsAggregator;\n  _info: Info = new Info();\n  _mostlyBlankStartTime: ?number = null;\n  _samplesStartTime: ?number = null;\n\n  static addListener(callback: FillRateInfo => void): {\n    remove: () => void,\n    ...\n  } {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n    _listeners.push(callback);\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      },\n    };\n  }\n\n  static setSampleRate(sampleRate: number) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount: number) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(listMetrics: ListMetricsAggregator) {\n    this._listMetrics = listMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n    const start = this._samplesStartTime; // const for flow\n    if (start == null) {\n      DEBUG &&\n        console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n      return;\n    }\n    const total_time_spent = global.performance.now() - start;\n    const info: any = {\n      ...this._info,\n      total_time_spent,\n    };\n    if (DEBUG) {\n      const derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank:\n          this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min:\n          this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min:\n          this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent,\n      };\n      for (const key in derived) {\n        // $FlowFixMe[prop-missing]\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n      console.debug('FillRateHelper deactivateAndFlush: ', {derived, info});\n    }\n    _listeners.forEach(listener => listener(info));\n    this._resetData();\n  }\n\n  computeBlankness(\n    props: {\n      ...CellMetricProps,\n      initialNumToRender?: ?number,\n      ...\n    },\n    cellsAroundViewport: {\n      first: number,\n      last: number,\n      ...\n    },\n    scrollMetrics: {\n      dOffset: number,\n      offset: number,\n      velocity: number,\n      visibleLength: number,\n      ...\n    },\n  ): number {\n    if (\n      !this._enabled ||\n      props.getItemCount(props.data) === 0 ||\n      cellsAroundViewport.last < cellsAroundViewport.first ||\n      this._samplesStartTime == null\n    ) {\n      return 0;\n    }\n    const {dOffset, offset, velocity, visibleLength} = scrollMetrics;\n\n    // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    const scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n    const now = global.performance.now();\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n    this._anyBlankStartTime = null;\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n    this._mostlyBlankStartTime = null;\n\n    let blankTop = 0;\n    let first = cellsAroundViewport.first;\n    let firstFrame = this._listMetrics.getCellMetrics(first, props);\n    while (\n      first <= cellsAroundViewport.last &&\n      (!firstFrame || !firstFrame.isMounted)\n    ) {\n      firstFrame = this._listMetrics.getCellMetrics(first, props);\n      first++;\n    }\n    // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(\n        visibleLength,\n        Math.max(0, firstFrame.offset - offset),\n      );\n    }\n    let blankBottom = 0;\n    let last = cellsAroundViewport.last;\n    let lastFrame = this._listMetrics.getCellMetrics(last, props);\n    while (\n      last >= cellsAroundViewport.first &&\n      (!lastFrame || !lastFrame.isMounted)\n    ) {\n      lastFrame = this._listMetrics.getCellMetrics(last, props);\n      last--;\n    }\n    // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      const bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(\n        visibleLength,\n        Math.max(0, offset + visibleLength - bottomEdge),\n      );\n    }\n    const pixels_blank = Math.round(blankTop + blankBottom);\n    const blankness = pixels_blank / visibleLength;\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n    return blankness;\n  }\n\n  enabled(): boolean {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n}\n\nmodule.exports = FillRateHelper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}